# The app only queries with a depth of 1 level. By default, all patterns are rooted to the top-level.
# To recurse into a module/namespace/etc. an element must set the `recurse` directive.
#
# For instance, function patterns will only match free functions at the top level. To match methods,
# you should create a class/impl/etc. pattern that includes methods in its definition list. However,
# to match functions inside a namespace, you would create a namespace pattern with the recurse directive,
# but no explicit function patterns inside.
#
# Tip: use InspectTree from an nvim instance to visualize the parse structure of a source file. Otherwise,
# write a script to use tree-sitter to dump out the s-expression for a file, non-interactively.
javascript:
  extensions:
    - js
  grammar_path: https://github.com/tree-sitter/tree-sitter-javascript/releases/download/v0.23.1/tree-sitter-javascript.wasm
  queries: {}
rust:
  extensions:
    - rs
  grammar_path: https://github.com/tree-sitter/tree-sitter-rust/releases/download/v0.24.0/tree-sitter-rust.wasm
  queries:
    traits: |
      (trait_item
          name: [(type_identifier) (generic_type)] @name.definition.interface) @definition.interface
    types: |
      (struct_item
          name: [(type_identifier) (generic_type)] @name.definition.class) @definition.class
      (enum_item
          name: (type_identifier) @name.definition.class) @definition.class
      (union_item
          name: (type_identifier) @name.definition.class) @definition.class
      (type_item
          name: (type_identifier) @name.definition.class) @definition.class

    # Capturing attributes on functions, since there may be variants for different cfg features
    functions: |
      (
          (
            (attribute_item (attribute) @attribute)
            .
            [(line_comment) (block_comment)]*
          )*
          .
          (function_item
              name: (identifier) @name.definition.function)
      ) @definition.function

    methods: |
      (impl_item
          trait: [(type_identifier) (generic_type)] @name.reference.interface
          type: [(type_identifier) (generic_type)] @name.reference.class
          body: (declaration_list
              (function_item
                  name: (identifier) @name.definition.method) @definition.method
          )
      )

      (impl_item
          type: (type_identifier) @name.reference.class
          !trait
          body: (declaration_list
              (function_item
                  name: (identifier) @name.definition.method) @definition.method
          )
      )

    modules: |
      (mod_item
          name: (identifier) @name.definition.module
          body: (declaration_list)
          (#set! recurse)) @definition.module

  templates:
    class_member: |
      Member function of {{class_type}}:
      ```rust
      {{code}}
      ```
    impl_trait: |
      Implementation of trait {{trait_type}} for {{class_type}}:
      ```rust
      {{code}}
      ```
