# The app only queries with a depth of 1 level. By default, all patterns are rooted to the top-level.
# To recurse into a module/namespace/etc. an element must set the `recurse` directive.
#
# For instance, function patterns will only match free functions at the top level. To match methods,
# you should create a class/impl/etc. pattern that includes methods in its definition list. However,
# to match functions inside a namespace, you would create a namespace pattern with the recurse directive,
# but no explicit function patterns inside.
javascript:
  extensions:
    - js
  grammar_path: https://github.com/tree-sitter/tree-sitter-javascript/releases/download/v0.23.1/tree-sitter-javascript.wasm
  queries:
    methods: |
      (
        (comment)* @doc
        .
        (method_definition
          name: (property_identifier) @name.definition.method) @definition.method
        (#not-eq? @name.definition.method "constructor")
        (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
        (#select-adjacent! @doc @definition.method)
      )
    classes: |
      (
        (comment)* @doc
        .
        [
          (class
            name: (_) @name.definition.class)
          (class_declaration
            name: (_) @name.definition.class)
        ] @definition.class
        (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
        (#select-adjacent! @doc @definition.class)
      )
    functions: |
      (
        (comment)* @doc
        .
        [
          (function_expression
            name: (identifier) @name.definition.function)
          (function_declaration
            name: (identifier) @name.definition.function)
          (generator_function
            name: (identifier) @name.definition.function)
          (generator_function_declaration
            name: (identifier) @name.definition.function)
        ] @definition.function
        (#strip! @doc "^[\\s\\*/]+|^[\\s\\*/]$")
        (#select-adjacent! @doc @definition.function)
      )
rust:
  extensions:
    - rs
  grammar_path: https://github.com/tree-sitter/tree-sitter-rust/releases/download/v0.24.0/tree-sitter-rust.wasm
  queries:
    traits: |
      (trait_item
          name: (type_identifier) @name.definition.interface) @definition.interface
    types: |
      (struct_item
          name: (type_identifier) @name.definition.class) @definition.class
      (enum_item
          name: (type_identifier) @name.definition.class) @definition.class
      (union_item
          name: (type_identifier) @name.definition.class) @definition.class
      (type_item
          name: (type_identifier) @name.definition.class) @definition.class

    functions: |
      (function_item
          name: (identifier) @name.definition.function) @definition.function

    methods: |
      (impl_item
          trait: (type_identifier) @name.reference.interface
          type: (type_identifier) @name.reference.class
          body: (declaration_list
              (function_item
                  name: (identifier) @name.definition.method) @definition.method
          )
      )

      (impl_item
          type: (type_identifier) @name.reference.class
          !trait
          body: (declaration_list
              (function_item
                  name: (identifier) @name.definition.method) @definition.method
          )
      )

    modules: |
      (mod_item
          name: (identifier) @name.definition.module
          body: (declaration_list)
          (#set! recurse)) @definition.module

#      #### Seems to overlap with functions. Need to check tree-sitter docs
#      methods: |
#        (declaration_list
#            (function_item
#                name: (identifier) @name.definition.method) @definition.method)
#
#     modules: |
#       (mod_item
#           name: (identifier) @name.definition.module) @definition.module
#
#     other: |
#       ; macro definitions
#
#       (macro_definition
#           name: (identifier) @name.definition.macro) @definition.macro
#
#       ; references
#
#       (call_expression
#           function: (identifier) @name.reference.call) @reference.call
#
#       (call_expression
#           function: (field_expression
#               field: (field_identifier) @name.reference.call)) @reference.call
#
#       (macro_invocation
#           macro: (identifier) @name.reference.call) @reference.call
#
#       ; implementations
#
#       (impl_item
#           trait: (type_identifier) @name.reference.implementation) @reference.implementation
#
#       (impl_item
#           type: (type_identifier) @name.reference.implementation
#           !trait) @reference.implementation
